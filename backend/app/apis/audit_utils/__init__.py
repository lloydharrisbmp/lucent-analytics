"""Audit Log Utilities"""
import uuid
from datetime import datetime, timezone
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field

from fastapi import Request # To potentially get client info later

# Attempt to import the shared Firestore client getter
try:
    from app.apis.permission_utils import get_firestore_client
except ImportError:
    print("ERROR: Could not import get_firestore_client from permission_utils. Audit logging will likely fail.")
    # Define a placeholder if import fails to allow module loading, but log error.
    async def get_firestore_client():
        raise NotImplementedError("Firestore client could not be loaded.")

# --- Audit Log Model (Based on MYA-123) ---

class AuditLogEntry(BaseModel):
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    userId: str = Field(..., description="ID of the user performing the action (Firebase UID).")
    action: str = Field(..., description="Identifier for the action performed (e.g., 'create_report_definition', 'login_user').")
    entityType: Optional[str] = Field(None, description="Type of the entity affected (e.g., 'report_definition', 'user').")
    entityId: Optional[str] = Field(None, description="ID of the specific entity affected.")
    details: Optional[Dict[str, Any]] = Field(None, description="Additional contextual details about the event (e.g., parameters used, changes made).")
    status: str = Field(..., description="Outcome of the action ('success', 'failure', 'attempt').")
    clientInfo: Optional[Dict[str, Any]] = Field(None, description="Information about the client making the request (e.g., IP address, user agent).") # Placeholder for now
    
    # Automatically generated log entry ID (separate from Firestore doc ID)
    logId: str = Field(default_factory=lambda: str(uuid.uuid4()))

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat() # Ensure consistent ISO format
        }
        
# --- Audit Log Function ---

async def log_audit_event(
    userId: str,
    action: str,
    status: str,
    entityType: Optional[str] = None,
    entityId: Optional[str] = None,
    details: Optional[Dict[str, Any]] = None,
    request: Optional[Request] = None # Pass request for client info later
):
    """
    Logs an audit event to the 'audit_logs' collection in Firestore.

    Args:
        userId: Firebase UID of the user.
        action: Action identifier string.
        status: 'success', 'failure', or 'attempt'.
        entityType: (Optional) Type of entity affected.
        entityId: (Optional) ID of the entity affected.
        details: (Optional) Dictionary of additional event details.
        request: (Optional) FastAPI Request object to extract client info.
    """
    try:
        client = await get_firestore_client() # Get the initialized Firestore client
        
        # TODO: Extract client info from request if provided
        client_info = None
        if request:
            # Example: Extract basic client info - consider privacy implications
            client_info = {
                "host": request.client.host if request.client else None,
                "user_agent": request.headers.get("user-agent")
            }

        log_entry = AuditLogEntry(
            userId=userId,
            action=action,
            status=status,
            entityType=entityType,
            entityId=entityId,
            details=details,
            clientInfo=client_info,
            # timestamp and logId are auto-generated by the model
        )

        # Convert Pydantic model to dict for Firestore
        log_data = log_entry.dict(exclude_none=True) # Exclude None fields for cleaner logs
        
        # Add the log entry to Firestore, letting Firestore generate the document ID
        doc_ref = await client.collection("audit_logs").add(log_data)
        
        # Optional: print confirmation with Firestore doc ID
        # print(f"Audit log created: {log_entry.logId} (Firestore Doc ID: {doc_ref[1].id})") 

    except NotImplementedError:
         print("CRITICAL ERROR: Firestore client not available. Audit event NOT logged.")
    except Exception as e:
        # Avoid crashing the main application flow if logging fails
        print(f"ERROR: Failed to log audit event. Action: {action}, User: {userId}. Error: {e}")

# Example usage (for testing):
# async def example_call():
#     await log_audit_event(
#         userId="test-user-123",
#         action="test_action",
#         status="success",
#         entityType="test_entity",
#         entityId="test-id-456",
#         details={"param1": "value1", "success": True}
#     )
# if __name__ == "__main__":
#     import asyncio
#     asyncio.run(example_call())

